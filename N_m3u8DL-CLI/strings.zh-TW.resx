<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="binaryMergingPleaseWait" xml:space="preserve">
    <value>二進制合並...請耐心等待</value>
  </data>
  <data name="disableIntegrityCheck" xml:space="preserve">
    <value>已關閉完整性檢查</value>
  </data>
  <data name="dolbyVisionContentMerging" xml:space="preserve">
    <value>杜比視界內容，使用二進制合並...請耐心等待</value>
  </data>
  <data name="downloadComplete" xml:space="preserve">
    <value>已下載完畢</value>
  </data>
  <data name="downloadedCount" xml:space="preserve">
    <value>完成數量 </value>
  </data>
  <data name="downloadFailed" xml:space="preserve">
    <value>下載失敗, 程序退出</value>
  </data>
  <data name="downloadingExternalAudioTrack" xml:space="preserve">
    <value>開始下載外掛音頻...</value>
  </data>
  <data name="downloadingExternalSubtitleTrack" xml:space="preserve">
    <value>開始下載外掛字幕...</value>
  </data>
  <data name="downloadingFirstSegement" xml:space="preserve">
    <value>下載首分片...</value>
  </data>
  <data name="downloadingM3u8" xml:space="preserve">
    <value>獲取m3u8內容</value>
  </data>
  <data name="downloadingM3u8Key" xml:space="preserve">
    <value>獲取m3u8 key...</value>
  </data>
  <data name="downloadingMapFile" xml:space="preserve">
    <value>下載MAP文件...</value>
  </data>
  <data name="ExitedCtrlC" xml:space="preserve">
    <value>強制退出: Ctrl+C</value>
  </data>
  <data name="ExitedForce" xml:space="preserve">
    <value>強制退出: 強制</value>
  </data>
  <data name="ffmpegDone" xml:space="preserve">
    <value>結果輸出至 [ffreport.log]</value>
  </data>
  <data name="ffmpegLost" xml:space="preserve">
    <value>在PATH和程序路徑下找不到 ffmpeg</value>
  </data>
  <data name="ffmpegMergingPleaseWait" xml:space="preserve">
    <value>使用ffmpeg合並...請耐心等待</value>
  </data>
  <data name="ffmpegTip" xml:space="preserve">
    <value>請下載ffmpeg.exe並把他放到程序同目錄.</value>
  </data>
  <data name="fileDuration" xml:space="preserve">
    <value>文件時長：</value>
  </data>
  <data name="fileName" xml:space="preserve">
    <value>文件名稱{0}：</value>
  </data>
  <data name="hasExternalAudioTrack" xml:space="preserve">
    <value>識別到外掛音頻軌道</value>
  </data>
  <data name="hasExternalSubtitleTrack" xml:space="preserve">
    <value>識別到外掛字幕軌道</value>
  </data>
  <data name="helpInfo" xml:space="preserve">
    <value>N_m3u8DL-CLI.exe &lt;URL|File|JSON&gt; [OPTIONS]  

    --workDir    Directory      設定程序工作目錄
    --saveName   Filename       設定存儲文件名(不包括後綴)
    --baseUrl    BaseUrl        設定Baseurl
    --headers    headers        設定請求頭，格式 key:value 使用|分割不同的key&amp;value
    --maxThreads Thread         設定程序的最大線程數(默認為32)
    --minThreads Thread         設定程序的最小線程數(默認為16)
    --retryCount Count          設定程序的重試次數(默認為15)
    --timeOut    Sec            設定程序網絡請求的超時時間(單位為秒，默認為10秒)
    --muxSetJson File           使用外部json文件定義混流選項
    --useKeyFile File           使用外部16字節文件定義AES-128解密KEY
    --useKeyBase64 Base64String 使用Base64字符串定義AES-128解密KEY
    --useKeyIV     HEXString    使用HEX字符串定義AES-128解密IV
    --downloadRange Range       僅下載視頻的壹部分分片或長度
    --liveRecDur HH:MM:SS       直播錄制時，達到此長度自動退出軟件
    --stopSpeed  Number         當速度低於此值時，重試(單位為KB/s)
    --maxSpeed   Number         設置下載速度上限(單位為KB/s)
    --enableDelAfterDone        開啟下載後刪除臨時文件夾的功能
    --enableMuxFastStart        開啟混流mp4的FastStart特性
    --enableBinaryMerge         開啟二進制合並分片
    --enableParseOnly           開啟僅解析模式(程序只進行到meta.json)
    --enableAudioOnly           合並時僅封裝音頻軌道
    --disableDateInfo           關閉混流中的日期寫入
    --noMerge                   禁用自動合並
    --noProxy                   不自動使用系統代理
    --disableIntegrityCheck     不檢測分片數量是否完整</value>
  </data>
  <data name="invalidM3u8" xml:space="preserve">
    <value>無效的m3u8</value>
  </data>
  <data name="InvalidUri" xml:space="preserve">
    <value>地址無效</value>
  </data>
  <data name="liveStreamFoundAndRecoding" xml:space="preserve">
    <value>識別為直播流, 開始錄制...</value>
  </data>
  <data name="masterListFound" xml:space="preserve">
    <value>識別到大師列表</value>
  </data>
  <data name="newerVerisonDownloaded" xml:space="preserve">
    <value>檢測到更新，版本：{0}! 新版下載成功，請您自行替換</value>
  </data>
  <data name="newerVerisonDownloadFailed" xml:space="preserve">
    <value>檢測到更新，版本：{0}! 新版下載失敗，請您自行下載</value>
  </data>
  <data name="newerVisionDetected" xml:space="preserve">
    <value>檢測到更新，版本：{0}! 正在嘗試自動下載新版</value>
  </data>
  <data name="notSupportMethod" xml:space="preserve">
    <value>不支持{0}加密方式,將不被處理,且強制開啟二進制合並</value>
  </data>
  <data name="parseExit" xml:space="preserve">
    <value>解析m3u8成功, 程序退出</value>
  </data>
  <data name="parsingM3u8" xml:space="preserve">
    <value>解析m3u8內容</value>
  </data>
  <data name="partialMergingPleaseWait" xml:space="preserve">
    <value>分片大於1800個，執行分部合並中...</value>
  </data>
  <data name="pressAnyKeyExit" xml:space="preserve">
    <value>按任意鍵退出.</value>
  </data>
  <data name="readingFileInfo" xml:space="preserve">
    <value>讀取文件信息...</value>
  </data>
  <data name="recordLimitReached" xml:space="preserve">
    <value>錄制已到達限定長度</value>
  </data>
  <data name="remuxToMPEGTS" xml:space="preserve">
    <value>將文件轉換到 MPEG-TS 封裝：</value>
  </data>
  <data name="retryCount" xml:space="preserve">
    <value>重試次數 </value>
  </data>
  <data name="savePath" xml:space="preserve">
    <value>存儲路徑：</value>
  </data>
  <data name="segCount" xml:space="preserve">
    <value>總分片：</value>
  </data>
  <data name="selectedCount" xml:space="preserve">
    <value>已選擇分片：</value>
  </data>
  <data name="selectPlaylist" xml:space="preserve">
    <value>已自動選擇最高清晰度</value>
  </data>
  <data name="SomethingWasWrong" xml:space="preserve">
    <value>遇到了某些錯誤!</value>
  </data>
  <data name="startDownloading" xml:space="preserve">
    <value>開始下載文件</value>
  </data>
  <data name="startMerging" xml:space="preserve">
    <value>開始合並分片...</value>
  </data>
  <data name="startParsing" xml:space="preserve">
    <value>開始解析 </value>
  </data>
  <data name="startReParsing" xml:space="preserve">
    <value>重新解析m3u8...</value>
  </data>
  <data name="taskDone" xml:space="preserve">
    <value>任務結束</value>
  </data>
  <data name="waitForCompletion" xml:space="preserve">
    <value>等待下載完成...</value>
  </data>
  <data name="wrtingMasterMeta" xml:space="preserve">
    <value>寫出playLists.json</value>
  </data>
  <data name="wrtingMeta" xml:space="preserve">
    <value>寫出meta.json</value>
  </data>
</root>